import { debug } from "@actions/core";
import { Context } from "@actions/github/lib/context";
import type { GitHub } from "@actions/github/lib/utils";
import { BookResult } from "../google-books";
import { updateSummary } from "./update-summary";

export const onIssueComment = async (
  owner: string,
  repo: string,
  context: Context,
  octokit: InstanceType<typeof GitHub>
) => {
  debug("Started onIssueComment");
  const issue = await octokit.issues.get({
    owner: context.issue.owner,
    repo: context.issue.repo,
    issue_number: context.issue.number,
  });
  debug(`Got issue #${issue.data.number}`);
  if (!issue.data.labels.find((i) => i.name === "kind: book"))
    return debug('Issue not of "kind: book", skipping');
  if (issue.data.body.includes("This comment is autogenerated"))
    return debug("Comment was autogenerated, skipping");

  const comments = await octokit.issues.listComments({
    owner: context.issue.owner,
    repo: context.issue.repo,
    issue_number: context.issue.number,
  });
  debug(`Got ${comments.data.length} comments in issue`);
  if (comments.data.length < 2) return debug("Less than 2 comments, skipping");

  let json: BookResult | undefined = undefined;
  try {
    comments.data.forEach((comment) => {
      if (comment.body.includes("Book details (JSON)"))
        json = JSON.parse(comment.body.split("```json")[1].split("```")[0]) as BookResult;
    });
  } catch (error) {
    console.log("JSON parsing error", error);
  }
  debug("Got JSON data for book");

  const lastComment = comments.data.sort(
    (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
  )[0];
  if (!lastComment) throw new Error("Last comment not found");
  debug(`Found last comment #${lastComment.id}`);
  let progressPercent = 0;
  let totalPages = json ? (json as BookResult).pageCount : 1;
  if (lastComment.body.includes("/")) {
    const num = lastComment.body.split("/")[1].match(/\d+/g);
    if (num && num.length) {
      const potentialPages = parseInt(num[0]);
      if (!isNaN(potentialPages)) {
        totalPages = potentialPages;
        debug(`Total pages in book are ${totalPages}`);
      }
    }
  }
  const valuesInComment = lastComment.body.match(/\d+\%?/g);
  if (valuesInComment && valuesInComment.length) {
    const values = valuesInComment.map((val) => parseInt(val)).filter((val) => !isNaN(val));
    const firstVal = valuesInComment[0];
    if (values.length)
      if (firstVal.includes("%") && !isNaN(parseInt(firstVal)))
        progressPercent = parseInt(firstVal);
      else progressPercent = Math.max(Math.round(values[0] / totalPages), 100);
  }
  debug(`Progress is ${progressPercent}%`);
  if (progressPercent !== 0) {
    await octokit.reactions.createForIssueComment({
      owner: context.issue.owner,
      repo: context.issue.repo,
      issue_number: context.issue.number,
      comment_id: lastComment.id,
      content: "+1",
    });
    debug("Added reaction on comment");
    const currentPercentage = issue.data.title.match(/\(\d+\%\)/g);
    await octokit.issues.update({
      owner: context.issue.owner,
      repo: context.issue.repo,
      issue_number: context.issue.number,
      title:
        currentPercentage && currentPercentage.length
          ? `${issue.data.title.split(currentPercentage[0])} (${progressPercent}%)`
          : `${issue.data.title} (${progressPercent}%)`,
    });
    debug("Updated issue title with progress");
  }
  await updateSummary(owner, repo, context, octokit);
};
